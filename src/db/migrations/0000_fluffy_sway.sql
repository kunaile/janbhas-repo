-- Enhanced Migration: Schema + Triggers
-- Generated: 2025-09-29T04:34:56.119Z
-- ============================================================================

-- ============================================================================
-- SCHEMA MIGRATION (Generated by Drizzle)
-- ============================================================================

CREATE TYPE "public"."article_type" AS ENUM('standard', 'original', 'original_pro');--> statement-breakpoint
CREATE TABLE "article_tags" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"uid" uuid DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"created_by" uuid NOT NULL,
	"updated_at" timestamp with time zone DEFAULT now() NOT NULL,
	"updated_by" uuid NOT NULL,
	"deleted_at" timestamp with time zone,
	"deleted_by" uuid,
	"article_id" uuid NOT NULL,
	"tag_id" uuid NOT NULL,
	"tag_name" varchar(100),
	"tag_local_name" varchar(100),
	CONSTRAINT "article_tags_uid_unique" UNIQUE("uid"),
	CONSTRAINT "article_tags_article_tag_unique" UNIQUE("article_id","tag_id")
);
--> statement-breakpoint
CREATE TABLE "articles" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"uid" uuid DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"created_by" uuid NOT NULL,
	"updated_at" timestamp with time zone DEFAULT now() NOT NULL,
	"updated_by" uuid NOT NULL,
	"deleted_at" timestamp with time zone,
	"deleted_by" uuid,
	"slug" varchar(255) NOT NULL,
	"title" varchar(255) NOT NULL,
	"local_title" varchar(255),
	"short_description" text,
	"markdown_content" text NOT NULL,
	"thumbnail_url" varchar(500),
	"audio_url" varchar(500),
	"word_count" integer,
	"article_type" "article_type" DEFAULT 'standard' NOT NULL,
	"series_id" uuid,
	"episode_number" integer,
	"is_published" boolean DEFAULT false NOT NULL,
	"published_at" timestamp with time zone,
	"published_by" uuid,
	"is_featured" boolean DEFAULT false NOT NULL,
	"featured_at" timestamp with time zone,
	"featured_by" uuid,
	"language_id" uuid NOT NULL,
	"category_id" uuid,
	"sub_category_id" uuid,
	"author_id" uuid,
	"editor_id" uuid,
	"author_name" varchar(255) NOT NULL,
	"author_local_name" varchar(255),
	"category_name" varchar(255) NOT NULL,
	"category_local_name" varchar(255),
	"sub_category_name" varchar(255),
	"sub_category_local_name" varchar(255),
	CONSTRAINT "articles_uid_unique" UNIQUE("uid"),
	CONSTRAINT "articles_slug_unique" UNIQUE("slug")
);
--> statement-breakpoint
CREATE TABLE "author_translations" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"uid" uuid DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"created_by" uuid NOT NULL,
	"updated_at" timestamp with time zone DEFAULT now() NOT NULL,
	"updated_by" uuid NOT NULL,
	"deleted_at" timestamp with time zone,
	"deleted_by" uuid,
	"author_id" uuid NOT NULL,
	"language_id" uuid NOT NULL,
	"local_name" varchar(255) NOT NULL,
	"bio" text,
	CONSTRAINT "author_translations_uid_unique" UNIQUE("uid"),
	CONSTRAINT "author_translations_author_language_unique" UNIQUE("author_id","language_id")
);
--> statement-breakpoint
CREATE TABLE "authors" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"uid" uuid DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"created_by" uuid NOT NULL,
	"updated_at" timestamp with time zone DEFAULT now() NOT NULL,
	"updated_by" uuid NOT NULL,
	"deleted_at" timestamp with time zone,
	"deleted_by" uuid,
	"name" varchar(255) NOT NULL,
	"bio" text,
	"image_url" text,
	CONSTRAINT "authors_uid_unique" UNIQUE("uid")
);
--> statement-breakpoint
CREATE TABLE "categories" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"uid" uuid DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"created_by" uuid NOT NULL,
	"updated_at" timestamp with time zone DEFAULT now() NOT NULL,
	"updated_by" uuid NOT NULL,
	"deleted_at" timestamp with time zone,
	"deleted_by" uuid,
	"name" varchar(255) NOT NULL,
	CONSTRAINT "categories_uid_unique" UNIQUE("uid"),
	CONSTRAINT "categories_name_unique" UNIQUE("name")
);
--> statement-breakpoint
CREATE TABLE "category_translations" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"uid" uuid DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"created_by" uuid NOT NULL,
	"updated_at" timestamp with time zone DEFAULT now() NOT NULL,
	"updated_by" uuid NOT NULL,
	"deleted_at" timestamp with time zone,
	"deleted_by" uuid,
	"category_id" uuid NOT NULL,
	"language_id" uuid NOT NULL,
	"local_name" varchar(255) NOT NULL,
	CONSTRAINT "category_translations_uid_unique" UNIQUE("uid"),
	CONSTRAINT "category_translations_category_language_unique" UNIQUE("category_id","language_id")
);
--> statement-breakpoint
CREATE TABLE "editors" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"uid" uuid DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"updated_at" timestamp with time zone DEFAULT now() NOT NULL,
	"deleted_at" timestamp with time zone,
	"name" varchar(255) NOT NULL,
	"email" varchar(255),
	"image_url" text,
	"github_user_name" varchar(255),
	CONSTRAINT "editors_uid_unique" UNIQUE("uid")
);
--> statement-breakpoint
CREATE TABLE "languages" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"uid" uuid DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"created_by" uuid NOT NULL,
	"updated_at" timestamp with time zone DEFAULT now() NOT NULL,
	"updated_by" uuid NOT NULL,
	"deleted_at" timestamp with time zone,
	"deleted_by" uuid,
	"name" varchar(255) NOT NULL,
	"code" varchar(10) NOT NULL,
	CONSTRAINT "languages_uid_unique" UNIQUE("uid"),
	CONSTRAINT "languages_name_unique" UNIQUE("name"),
	CONSTRAINT "languages_code_unique" UNIQUE("code")
);
--> statement-breakpoint
CREATE TABLE "newsletter_submissions" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"ip_hash" varchar(64) NOT NULL,
	"session_id" varchar(64),
	"browser_fp" varchar(64),
	"submission_time" timestamp with time zone DEFAULT now() NOT NULL,
	"form_interaction_time" integer,
	"honeypot_triggered" boolean DEFAULT false,
	"source" varchar(100) NOT NULL
);
--> statement-breakpoint
CREATE TABLE "newsletter_subscribers" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"uid" uuid DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"created_by" uuid NOT NULL,
	"updated_at" timestamp with time zone DEFAULT now() NOT NULL,
	"updated_by" uuid NOT NULL,
	"deleted_at" timestamp with time zone,
	"deleted_by" uuid,
	"email" varchar(320) NOT NULL,
	"status" varchar(20) DEFAULT 'pending' NOT NULL,
	"source" varchar(100) NOT NULL,
	"language" varchar(10),
	"country_code" varchar(2),
	"region_code" varchar(10),
	"city" varchar(100),
	"latitude" numeric(10, 6),
	"longitude" numeric(10, 6),
	"continent" varchar(50),
	"district" varchar(100),
	"zip_code" varchar(20),
	"isp" varchar(200),
	"is_proxy" boolean DEFAULT false,
	"is_mobile" boolean DEFAULT false,
	"is_hosting" boolean DEFAULT false,
	"location_data" jsonb,
	"browser_family" varchar(50),
	"os_family" varchar(50),
	"device_type" varchar(20),
	"referrer_domain" varchar(255),
	"timezone" varchar(50),
	"verification_token" uuid DEFAULT gen_random_uuid(),
	"verified_at" timestamp with time zone,
	CONSTRAINT "newsletter_subscribers_uid_unique" UNIQUE("uid"),
	CONSTRAINT "newsletter_subscribers_email_unique" UNIQUE("email")
);
--> statement-breakpoint
CREATE TABLE "publication_events" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"article_id" uuid,
	"series_id" uuid,
	"event_type" varchar(20) NOT NULL,
	"performed_by" uuid NOT NULL,
	"event_date" timestamp with time zone DEFAULT now() NOT NULL,
	"reason" text,
	"metadata" jsonb,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "series" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"uid" uuid DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"created_by" uuid NOT NULL,
	"updated_at" timestamp with time zone DEFAULT now() NOT NULL,
	"updated_by" uuid NOT NULL,
	"deleted_at" timestamp with time zone,
	"deleted_by" uuid,
	"slug" varchar(255) NOT NULL,
	"title" varchar(255) NOT NULL,
	"local_title" varchar(255),
	"short_description" text,
	"markdown_content" text NOT NULL,
	"thumbnail_url" varchar(500),
	"total_episodes" integer DEFAULT 0 NOT NULL,
	"total_word_count" integer DEFAULT 0,
	"is_published" boolean DEFAULT false NOT NULL,
	"published_at" timestamp with time zone,
	"published_by" uuid,
	"is_featured" boolean DEFAULT false NOT NULL,
	"featured_at" timestamp with time zone,
	"featured_by" uuid,
	"is_complete" boolean DEFAULT false NOT NULL,
	"completed_at" timestamp with time zone,
	"language_id" uuid NOT NULL,
	"category_id" uuid,
	"sub_category_id" uuid,
	"author_id" uuid,
	"editor_id" uuid,
	"author_name" varchar(255) NOT NULL,
	"author_local_name" varchar(255),
	"category_name" varchar(255) NOT NULL,
	"category_local_name" varchar(255),
	"sub_category_name" varchar(255),
	"sub_category_local_name" varchar(255),
	CONSTRAINT "series_uid_unique" UNIQUE("uid"),
	CONSTRAINT "series_slug_unique" UNIQUE("slug")
);
--> statement-breakpoint
CREATE TABLE "sub_categories" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"uid" uuid DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"created_by" uuid NOT NULL,
	"updated_at" timestamp with time zone DEFAULT now() NOT NULL,
	"updated_by" uuid NOT NULL,
	"deleted_at" timestamp with time zone,
	"deleted_by" uuid,
	"name" varchar(255) NOT NULL,
	"category_id" uuid NOT NULL,
	CONSTRAINT "sub_categories_uid_unique" UNIQUE("uid")
);
--> statement-breakpoint
CREATE TABLE "sub_category_translations" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"uid" uuid DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"created_by" uuid NOT NULL,
	"updated_at" timestamp with time zone DEFAULT now() NOT NULL,
	"updated_by" uuid NOT NULL,
	"deleted_at" timestamp with time zone,
	"deleted_by" uuid,
	"sub_category_id" uuid NOT NULL,
	"language_id" uuid NOT NULL,
	"local_name" varchar(255) NOT NULL,
	CONSTRAINT "sub_category_translations_uid_unique" UNIQUE("uid"),
	CONSTRAINT "sub_category_translations_sub_category_language_unique" UNIQUE("sub_category_id","language_id")
);
--> statement-breakpoint
CREATE TABLE "tag_translations" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"uid" uuid DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"created_by" uuid NOT NULL,
	"updated_at" timestamp with time zone DEFAULT now() NOT NULL,
	"updated_by" uuid NOT NULL,
	"deleted_at" timestamp with time zone,
	"deleted_by" uuid,
	"tag_id" uuid NOT NULL,
	"language_id" uuid NOT NULL,
	"local_name" varchar(100) NOT NULL,
	CONSTRAINT "tag_translations_uid_unique" UNIQUE("uid"),
	CONSTRAINT "tag_translations_tag_language_unique" UNIQUE("tag_id","language_id")
);
--> statement-breakpoint
CREATE TABLE "tags" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"uid" uuid DEFAULT gen_random_uuid() NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"created_by" uuid NOT NULL,
	"updated_at" timestamp with time zone DEFAULT now() NOT NULL,
	"updated_by" uuid NOT NULL,
	"deleted_at" timestamp with time zone,
	"deleted_by" uuid,
	"name" varchar(100) NOT NULL,
	"slug" varchar(100) NOT NULL,
	CONSTRAINT "tags_uid_unique" UNIQUE("uid"),
	CONSTRAINT "tags_name_unique" UNIQUE("name"),
	CONSTRAINT "tags_slug_unique" UNIQUE("slug")
);
--> statement-breakpoint
ALTER TABLE "article_tags" ADD CONSTRAINT "article_tags_created_by_editors_id_fk" FOREIGN KEY ("created_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "article_tags" ADD CONSTRAINT "article_tags_updated_by_editors_id_fk" FOREIGN KEY ("updated_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "article_tags" ADD CONSTRAINT "article_tags_deleted_by_editors_id_fk" FOREIGN KEY ("deleted_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "article_tags" ADD CONSTRAINT "article_tags_article_id_articles_id_fk" FOREIGN KEY ("article_id") REFERENCES "public"."articles"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "article_tags" ADD CONSTRAINT "article_tags_tag_id_tags_id_fk" FOREIGN KEY ("tag_id") REFERENCES "public"."tags"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "articles" ADD CONSTRAINT "articles_created_by_editors_id_fk" FOREIGN KEY ("created_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "articles" ADD CONSTRAINT "articles_updated_by_editors_id_fk" FOREIGN KEY ("updated_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "articles" ADD CONSTRAINT "articles_deleted_by_editors_id_fk" FOREIGN KEY ("deleted_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "articles" ADD CONSTRAINT "articles_series_id_series_id_fk" FOREIGN KEY ("series_id") REFERENCES "public"."series"("id") ON DELETE set null ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "articles" ADD CONSTRAINT "articles_published_by_editors_id_fk" FOREIGN KEY ("published_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "articles" ADD CONSTRAINT "articles_featured_by_editors_id_fk" FOREIGN KEY ("featured_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "articles" ADD CONSTRAINT "articles_language_id_languages_id_fk" FOREIGN KEY ("language_id") REFERENCES "public"."languages"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "articles" ADD CONSTRAINT "articles_category_id_categories_id_fk" FOREIGN KEY ("category_id") REFERENCES "public"."categories"("id") ON DELETE set null ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "articles" ADD CONSTRAINT "articles_sub_category_id_sub_categories_id_fk" FOREIGN KEY ("sub_category_id") REFERENCES "public"."sub_categories"("id") ON DELETE set null ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "articles" ADD CONSTRAINT "articles_author_id_authors_id_fk" FOREIGN KEY ("author_id") REFERENCES "public"."authors"("id") ON DELETE set null ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "articles" ADD CONSTRAINT "articles_editor_id_editors_id_fk" FOREIGN KEY ("editor_id") REFERENCES "public"."editors"("id") ON DELETE set null ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "author_translations" ADD CONSTRAINT "author_translations_created_by_editors_id_fk" FOREIGN KEY ("created_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "author_translations" ADD CONSTRAINT "author_translations_updated_by_editors_id_fk" FOREIGN KEY ("updated_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "author_translations" ADD CONSTRAINT "author_translations_deleted_by_editors_id_fk" FOREIGN KEY ("deleted_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "author_translations" ADD CONSTRAINT "author_translations_author_id_authors_id_fk" FOREIGN KEY ("author_id") REFERENCES "public"."authors"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "author_translations" ADD CONSTRAINT "author_translations_language_id_languages_id_fk" FOREIGN KEY ("language_id") REFERENCES "public"."languages"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "authors" ADD CONSTRAINT "authors_created_by_editors_id_fk" FOREIGN KEY ("created_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "authors" ADD CONSTRAINT "authors_updated_by_editors_id_fk" FOREIGN KEY ("updated_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "authors" ADD CONSTRAINT "authors_deleted_by_editors_id_fk" FOREIGN KEY ("deleted_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "categories" ADD CONSTRAINT "categories_created_by_editors_id_fk" FOREIGN KEY ("created_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "categories" ADD CONSTRAINT "categories_updated_by_editors_id_fk" FOREIGN KEY ("updated_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "categories" ADD CONSTRAINT "categories_deleted_by_editors_id_fk" FOREIGN KEY ("deleted_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "category_translations" ADD CONSTRAINT "category_translations_created_by_editors_id_fk" FOREIGN KEY ("created_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "category_translations" ADD CONSTRAINT "category_translations_updated_by_editors_id_fk" FOREIGN KEY ("updated_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "category_translations" ADD CONSTRAINT "category_translations_deleted_by_editors_id_fk" FOREIGN KEY ("deleted_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "category_translations" ADD CONSTRAINT "category_translations_category_id_categories_id_fk" FOREIGN KEY ("category_id") REFERENCES "public"."categories"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "category_translations" ADD CONSTRAINT "category_translations_language_id_languages_id_fk" FOREIGN KEY ("language_id") REFERENCES "public"."languages"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "languages" ADD CONSTRAINT "languages_created_by_editors_id_fk" FOREIGN KEY ("created_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "languages" ADD CONSTRAINT "languages_updated_by_editors_id_fk" FOREIGN KEY ("updated_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "languages" ADD CONSTRAINT "languages_deleted_by_editors_id_fk" FOREIGN KEY ("deleted_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "newsletter_subscribers" ADD CONSTRAINT "newsletter_subscribers_created_by_editors_id_fk" FOREIGN KEY ("created_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "newsletter_subscribers" ADD CONSTRAINT "newsletter_subscribers_updated_by_editors_id_fk" FOREIGN KEY ("updated_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "newsletter_subscribers" ADD CONSTRAINT "newsletter_subscribers_deleted_by_editors_id_fk" FOREIGN KEY ("deleted_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "publication_events" ADD CONSTRAINT "publication_events_article_id_articles_id_fk" FOREIGN KEY ("article_id") REFERENCES "public"."articles"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "publication_events" ADD CONSTRAINT "publication_events_series_id_series_id_fk" FOREIGN KEY ("series_id") REFERENCES "public"."series"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "publication_events" ADD CONSTRAINT "publication_events_performed_by_editors_id_fk" FOREIGN KEY ("performed_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "series" ADD CONSTRAINT "series_created_by_editors_id_fk" FOREIGN KEY ("created_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "series" ADD CONSTRAINT "series_updated_by_editors_id_fk" FOREIGN KEY ("updated_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "series" ADD CONSTRAINT "series_deleted_by_editors_id_fk" FOREIGN KEY ("deleted_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "series" ADD CONSTRAINT "series_published_by_editors_id_fk" FOREIGN KEY ("published_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "series" ADD CONSTRAINT "series_featured_by_editors_id_fk" FOREIGN KEY ("featured_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "series" ADD CONSTRAINT "series_language_id_languages_id_fk" FOREIGN KEY ("language_id") REFERENCES "public"."languages"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "series" ADD CONSTRAINT "series_category_id_categories_id_fk" FOREIGN KEY ("category_id") REFERENCES "public"."categories"("id") ON DELETE set null ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "series" ADD CONSTRAINT "series_sub_category_id_sub_categories_id_fk" FOREIGN KEY ("sub_category_id") REFERENCES "public"."sub_categories"("id") ON DELETE set null ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "series" ADD CONSTRAINT "series_author_id_authors_id_fk" FOREIGN KEY ("author_id") REFERENCES "public"."authors"("id") ON DELETE set null ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "series" ADD CONSTRAINT "series_editor_id_editors_id_fk" FOREIGN KEY ("editor_id") REFERENCES "public"."editors"("id") ON DELETE set null ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "sub_categories" ADD CONSTRAINT "sub_categories_created_by_editors_id_fk" FOREIGN KEY ("created_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "sub_categories" ADD CONSTRAINT "sub_categories_updated_by_editors_id_fk" FOREIGN KEY ("updated_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "sub_categories" ADD CONSTRAINT "sub_categories_deleted_by_editors_id_fk" FOREIGN KEY ("deleted_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "sub_categories" ADD CONSTRAINT "sub_categories_category_id_categories_id_fk" FOREIGN KEY ("category_id") REFERENCES "public"."categories"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "sub_category_translations" ADD CONSTRAINT "sub_category_translations_created_by_editors_id_fk" FOREIGN KEY ("created_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "sub_category_translations" ADD CONSTRAINT "sub_category_translations_updated_by_editors_id_fk" FOREIGN KEY ("updated_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "sub_category_translations" ADD CONSTRAINT "sub_category_translations_deleted_by_editors_id_fk" FOREIGN KEY ("deleted_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "sub_category_translations" ADD CONSTRAINT "sub_category_translations_sub_category_id_sub_categories_id_fk" FOREIGN KEY ("sub_category_id") REFERENCES "public"."sub_categories"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "sub_category_translations" ADD CONSTRAINT "sub_category_translations_language_id_languages_id_fk" FOREIGN KEY ("language_id") REFERENCES "public"."languages"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "tag_translations" ADD CONSTRAINT "tag_translations_created_by_editors_id_fk" FOREIGN KEY ("created_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "tag_translations" ADD CONSTRAINT "tag_translations_updated_by_editors_id_fk" FOREIGN KEY ("updated_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "tag_translations" ADD CONSTRAINT "tag_translations_deleted_by_editors_id_fk" FOREIGN KEY ("deleted_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "tag_translations" ADD CONSTRAINT "tag_translations_tag_id_tags_id_fk" FOREIGN KEY ("tag_id") REFERENCES "public"."tags"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "tag_translations" ADD CONSTRAINT "tag_translations_language_id_languages_id_fk" FOREIGN KEY ("language_id") REFERENCES "public"."languages"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "tags" ADD CONSTRAINT "tags_created_by_editors_id_fk" FOREIGN KEY ("created_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "tags" ADD CONSTRAINT "tags_updated_by_editors_id_fk" FOREIGN KEY ("updated_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "tags" ADD CONSTRAINT "tags_deleted_by_editors_id_fk" FOREIGN KEY ("deleted_by") REFERENCES "public"."editors"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
CREATE INDEX "article_tags_article_idx" ON "article_tags" USING btree ("article_id");--> statement-breakpoint
CREATE INDEX "article_tags_tag_idx" ON "article_tags" USING btree ("tag_id");--> statement-breakpoint
CREATE INDEX "articles_slug_idx" ON "articles" USING btree ("slug");--> statement-breakpoint
CREATE INDEX "articles_published_idx" ON "articles" USING btree ("is_published","published_at" DESC NULLS LAST);--> statement-breakpoint
CREATE INDEX "articles_featured_idx" ON "articles" USING btree ("is_featured");--> statement-breakpoint
CREATE INDEX "articles_language_idx" ON "articles" USING btree ("language_id");--> statement-breakpoint
CREATE INDEX "articles_category_idx" ON "articles" USING btree ("category_id");--> statement-breakpoint
CREATE INDEX "articles_author_idx" ON "articles" USING btree ("author_id");--> statement-breakpoint
CREATE INDEX "articles_series_episode_idx" ON "articles" USING btree ("series_id","episode_number");--> statement-breakpoint
CREATE INDEX "articles_type_idx" ON "articles" USING btree ("article_type");--> statement-breakpoint
CREATE INDEX "articles_published_category_idx" ON "articles" USING btree ("is_published","category_id","language_id");--> statement-breakpoint
CREATE INDEX "author_translations_author_language_idx" ON "author_translations" USING btree ("author_id","language_id");--> statement-breakpoint
CREATE INDEX "authors_name_idx" ON "authors" USING btree ("name");--> statement-breakpoint
CREATE INDEX "categories_name_idx" ON "categories" USING btree ("name");--> statement-breakpoint
CREATE INDEX "category_translations_category_language_idx" ON "category_translations" USING btree ("category_id","language_id");--> statement-breakpoint
CREATE INDEX "editors_email_idx" ON "editors" USING btree ("email");--> statement-breakpoint
CREATE INDEX "editors_github_idx" ON "editors" USING btree ("github_user_name");--> statement-breakpoint
CREATE INDEX "newsletter_ip_idx" ON "newsletter_submissions" USING btree ("ip_hash");--> statement-breakpoint
CREATE INDEX "newsletter_fp_idx" ON "newsletter_submissions" USING btree ("browser_fp");--> statement-breakpoint
CREATE INDEX "newsletter_email_idx" ON "newsletter_subscribers" USING btree ("email");--> statement-breakpoint
CREATE INDEX "newsletter_status_idx" ON "newsletter_subscribers" USING btree ("status");--> statement-breakpoint
CREATE INDEX "publication_events_article_idx" ON "publication_events" USING btree ("article_id","event_type");--> statement-breakpoint
CREATE INDEX "publication_events_series_idx" ON "publication_events" USING btree ("series_id","event_type");--> statement-breakpoint
CREATE INDEX "publication_events_editor_idx" ON "publication_events" USING btree ("performed_by","event_date" DESC NULLS LAST);--> statement-breakpoint
CREATE INDEX "publication_events_date_idx" ON "publication_events" USING btree ("event_date" DESC NULLS LAST);--> statement-breakpoint
CREATE INDEX "series_slug_idx" ON "series" USING btree ("slug");--> statement-breakpoint
CREATE INDEX "series_published_idx" ON "series" USING btree ("is_published","published_at" DESC NULLS LAST);--> statement-breakpoint
CREATE INDEX "series_featured_idx" ON "series" USING btree ("is_featured","published_at" DESC NULLS LAST);--> statement-breakpoint
CREATE INDEX "series_language_idx" ON "series" USING btree ("language_id");--> statement-breakpoint
CREATE INDEX "series_category_idx" ON "series" USING btree ("category_id");--> statement-breakpoint
CREATE INDEX "series_author_idx" ON "series" USING btree ("author_id");--> statement-breakpoint
CREATE INDEX "sub_categories_category_idx" ON "sub_categories" USING btree ("category_id");--> statement-breakpoint
CREATE INDEX "sub_categories_name_idx" ON "sub_categories" USING btree ("name");--> statement-breakpoint
CREATE INDEX "sub_category_translations_sub_category_language_idx" ON "sub_category_translations" USING btree ("sub_category_id","language_id");--> statement-breakpoint
CREATE INDEX "tag_translations_tag_language_idx" ON "tag_translations" USING btree ("tag_id","language_id");--> statement-breakpoint
CREATE INDEX "tags_slug_idx" ON "tags" USING btree ("slug");

-- ============================================================================
-- DATABASE TRIGGERS (Automatic Synchronization)
-- ============================================================================

-- src/db/triggers/sync-triggers.sql

-- ============================================================================
-- MULTILINGUAL TRANSLATION SYNCHRONIZATION TRIGGERS
-- ============================================================================

-- ----------------------------------------------------------------------------
-- Author Translation Sync: Update articles when author translations change
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION sync_author_translations_to_articles()
RETURNS TRIGGER AS $$
BEGIN
  -- Update articles with new author local name for specific language
  UPDATE articles 
  SET 
    author_local_name = NEW.local_name,
    updated_at = NOW(),
    updated_by = NEW.updated_by
  WHERE author_id = NEW.author_id 
    AND language_id = NEW.language_id
    AND deleted_at IS NULL;
  
  -- Log the number of articles updated
  RAISE NOTICE 'Updated author translation for % articles', 
    (SELECT COUNT(*) FROM articles 
     WHERE author_id = NEW.author_id 
       AND language_id = NEW.language_id 
       AND deleted_at IS NULL);
       
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER sync_author_translations_trigger
  AFTER INSERT OR UPDATE ON author_translations
  FOR EACH ROW EXECUTE FUNCTION sync_author_translations_to_articles();

-- ----------------------------------------------------------------------------
-- Category Translation Sync: Update articles when category translations change
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION sync_category_translations_to_articles()
RETURNS TRIGGER AS $$
BEGIN
  -- Update articles with new category local name for specific language
  UPDATE articles 
  SET 
    category_local_name = NEW.local_name,
    updated_at = NOW(),
    updated_by = NEW.updated_by
  WHERE category_id = NEW.category_id 
    AND language_id = NEW.language_id
    AND deleted_at IS NULL;
  
  -- Also update series with same category and language
  UPDATE series 
  SET 
    category_local_name = NEW.local_name,
    updated_at = NOW(),
    updated_by = NEW.updated_by
  WHERE category_id = NEW.category_id 
    AND language_id = NEW.language_id
    AND deleted_at IS NULL;
    
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER sync_category_translations_trigger
  AFTER INSERT OR UPDATE ON category_translations
  FOR EACH ROW EXECUTE FUNCTION sync_category_translations_to_articles();

-- ----------------------------------------------------------------------------
-- Sub-Category Translation Sync: Update articles when sub-category translations change
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION sync_sub_category_translations_to_articles()
RETURNS TRIGGER AS $$
BEGIN
  -- Update articles with new sub-category local name for specific language
  UPDATE articles 
  SET 
    sub_category_local_name = NEW.local_name,
    updated_at = NOW(),
    updated_by = NEW.updated_by
  WHERE sub_category_id = NEW.sub_category_id 
    AND language_id = NEW.language_id
    AND deleted_at IS NULL;
  
  -- Also update series with same sub-category and language
  UPDATE series 
  SET 
    sub_category_local_name = NEW.local_name,
    updated_at = NOW(),
    updated_by = NEW.updated_by
  WHERE sub_category_id = NEW.sub_category_id 
    AND language_id = NEW.language_id
    AND deleted_at IS NULL;
    
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER sync_sub_category_translations_trigger
  AFTER INSERT OR UPDATE ON sub_category_translations
  FOR EACH ROW EXECUTE FUNCTION sync_sub_category_translations_to_articles();

-- ----------------------------------------------------------------------------
-- Tag Translation Sync: Update article_tags when tag translations change
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION sync_tag_translations_to_article_tags()
RETURNS TRIGGER AS $$
BEGIN
  -- Update article_tags with new tag local name for articles in specific language
  UPDATE article_tags 
  SET 
    tag_local_name = NEW.local_name,
    updated_at = NOW(),
    updated_by = NEW.updated_by
  WHERE tag_id = NEW.tag_id 
    AND EXISTS (
      SELECT 1 FROM articles a 
      WHERE a.id = article_tags.article_id 
        AND a.language_id = NEW.language_id
        AND a.deleted_at IS NULL
    )
    AND article_tags.deleted_at IS NULL;
    
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER sync_tag_translations_trigger
  AFTER INSERT OR UPDATE ON tag_translations
  FOR EACH ROW EXECUTE FUNCTION sync_tag_translations_to_article_tags();

-- ============================================================================
-- ARTICLE INSERTION TRIGGERS
-- ============================================================================

-- ----------------------------------------------------------------------------
-- Populate denormalized multilingual fields on article insert
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION populate_article_multilingual_fields()
RETURNS TRIGGER AS $$
BEGIN
  -- Populate author local name from translation table
  IF NEW.author_id IS NOT NULL AND NEW.language_id IS NOT NULL THEN
    SELECT local_name INTO NEW.author_local_name
    FROM author_translations 
    WHERE author_id = NEW.author_id 
      AND language_id = NEW.language_id
      AND deleted_at IS NULL
    LIMIT 1;
  END IF;
  
  -- Populate category local name from translation table
  IF NEW.category_id IS NOT NULL AND NEW.language_id IS NOT NULL THEN
    SELECT local_name INTO NEW.category_local_name
    FROM category_translations 
    WHERE category_id = NEW.category_id 
      AND language_id = NEW.language_id
      AND deleted_at IS NULL
    LIMIT 1;
  END IF;
  
  -- Populate sub-category local name from translation table
  IF NEW.sub_category_id IS NOT NULL AND NEW.language_id IS NOT NULL THEN
    SELECT local_name INTO NEW.sub_category_local_name
    FROM sub_category_translations 
    WHERE sub_category_id = NEW.sub_category_id 
      AND language_id = NEW.language_id
      AND deleted_at IS NULL
    LIMIT 1;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER populate_article_multilingual_trigger
  BEFORE INSERT ON articles
  FOR EACH ROW EXECUTE FUNCTION populate_article_multilingual_fields();

-- ----------------------------------------------------------------------------
-- Populate denormalized multilingual fields on series insert
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION populate_series_multilingual_fields()
RETURNS TRIGGER AS $$
BEGIN
  -- Populate author local name from translation table
  IF NEW.author_id IS NOT NULL AND NEW.language_id IS NOT NULL THEN
    SELECT local_name INTO NEW.author_local_name
    FROM author_translations 
    WHERE author_id = NEW.author_id 
      AND language_id = NEW.language_id
      AND deleted_at IS NULL
    LIMIT 1;
  END IF;
  
  -- Populate category local name from translation table
  IF NEW.category_id IS NOT NULL AND NEW.language_id IS NOT NULL THEN
    SELECT local_name INTO NEW.category_local_name
    FROM category_translations 
    WHERE category_id = NEW.category_id 
      AND language_id = NEW.language_id
      AND deleted_at IS NULL
    LIMIT 1;
  END IF;
  
  -- Populate sub-category local name from translation table
  IF NEW.sub_category_id IS NOT NULL AND NEW.language_id IS NOT NULL THEN
    SELECT local_name INTO NEW.sub_category_local_name
    FROM sub_category_translations 
    WHERE sub_category_id = NEW.sub_category_id 
      AND language_id = NEW.language_id
      AND deleted_at IS NULL
    LIMIT 1;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER populate_series_multilingual_trigger
  BEFORE INSERT ON series
  FOR EACH ROW EXECUTE FUNCTION populate_series_multilingual_fields();

-- ============================================================================
-- SERIES STATISTICS MANAGEMENT TRIGGERS
-- ============================================================================

-- ----------------------------------------------------------------------------
-- Update series statistics when articles change
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION update_series_statistics()
RETURNS TRIGGER AS $$
DECLARE
  target_series_id uuid;
  old_series_id uuid;
BEGIN
  -- Determine which series to update based on operation
  IF TG_OP = 'DELETE' THEN
    target_series_id := OLD.series_id;
  ELSIF TG_OP = 'UPDATE' THEN
    target_series_id := NEW.series_id;
    old_series_id := OLD.series_id;
  ELSE -- INSERT
    target_series_id := NEW.series_id;
  END IF;
  
  -- Update current series statistics
  IF target_series_id IS NOT NULL THEN
    UPDATE series SET
      total_episodes = (
        SELECT COUNT(*) FROM articles 
        WHERE series_id = target_series_id 
          AND deleted_at IS NULL
      ),
      total_word_count = (
        SELECT COALESCE(SUM(word_count), 0) FROM articles 
        WHERE series_id = target_series_id 
          AND deleted_at IS NULL
      ),
      updated_at = NOW()
    WHERE id = target_series_id;
  END IF;
  
  -- Update old series statistics if article moved between series
  IF TG_OP = 'UPDATE' AND old_series_id IS NOT NULL AND old_series_id != target_series_id THEN
    UPDATE series SET
      total_episodes = (
        SELECT COUNT(*) FROM articles 
        WHERE series_id = old_series_id 
          AND deleted_at IS NULL
      ),
      total_word_count = (
        SELECT COALESCE(SUM(word_count), 0) FROM articles 
        WHERE series_id = old_series_id 
          AND deleted_at IS NULL
      ),
      updated_at = NOW()
    WHERE id = old_series_id;
  END IF;
  
  -- Handle episode reordering on DELETE
  IF TG_OP = 'DELETE' AND OLD.series_id IS NOT NULL AND OLD.episode_number IS NOT NULL THEN
    -- Reorder episodes to fill the gap
    UPDATE articles 
    SET 
      episode_number = episode_number - 1,
      updated_at = NOW()
    WHERE series_id = OLD.series_id 
      AND episode_number > OLD.episode_number
      AND deleted_at IS NULL;
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_series_statistics_trigger
  AFTER INSERT OR UPDATE OR DELETE ON articles
  FOR EACH ROW EXECUTE FUNCTION update_series_statistics();

-- ============================================================================
-- EPISODE NUMBER MANAGEMENT
-- ============================================================================

-- ----------------------------------------------------------------------------
-- Auto-assign episode numbers for new episodes
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION assign_episode_number()
RETURNS TRIGGER AS $$
DECLARE
  next_episode integer;
BEGIN
  -- Only assign episode number if article is part of a series and episode_number is NULL
  IF NEW.series_id IS NOT NULL AND NEW.episode_number IS NULL THEN
    -- Get the next episode number for this series
    SELECT COALESCE(MAX(episode_number), 0) + 1 
    INTO next_episode
    FROM articles 
    WHERE series_id = NEW.series_id 
      AND deleted_at IS NULL;
    
    NEW.episode_number := next_episode;
    
    RAISE NOTICE 'Assigned episode number % to article % in series %', 
      next_episode, NEW.title, NEW.series_id;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER assign_episode_number_trigger
  BEFORE INSERT ON articles
  FOR EACH ROW EXECUTE FUNCTION assign_episode_number();

-- ============================================================================
-- ARTICLE_TAGS DENORMALIZATION TRIGGERS
-- ============================================================================

-- ----------------------------------------------------------------------------
-- Populate tag denormalized fields on article_tags insert
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION populate_article_tags_denormalized_fields()
RETURNS TRIGGER AS $$
DECLARE
  article_language_id uuid;
BEGIN
  -- Get the language of the article
  SELECT language_id INTO article_language_id
  FROM articles 
  WHERE id = NEW.article_id 
    AND deleted_at IS NULL;
  
  -- Populate tag name from tags table
  SELECT name INTO NEW.tag_name
  FROM tags 
  WHERE id = NEW.tag_id 
    AND deleted_at IS NULL;
  
  -- Populate tag local name from translation table
  IF article_language_id IS NOT NULL THEN
    SELECT local_name INTO NEW.tag_local_name
    FROM tag_translations 
    WHERE tag_id = NEW.tag_id 
      AND language_id = article_language_id
      AND deleted_at IS NULL
    LIMIT 1;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER populate_article_tags_denormalized_trigger
  BEFORE INSERT ON article_tags
  FOR EACH ROW EXECUTE FUNCTION populate_article_tags_denormalized_fields();

-- ============================================================================
-- PUBLICATION EVENT TRIGGERS
-- ============================================================================

-- ----------------------------------------------------------------------------
-- Auto-create publication events when publication status changes
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION track_publication_events()
RETURNS TRIGGER AS $$
BEGIN
  -- Track article publication status changes
  IF TG_TABLE_NAME = 'articles' THEN
    -- Publication status changed
    IF TG_OP = 'UPDATE' AND OLD.is_published != NEW.is_published THEN
      INSERT INTO publication_events (
        article_id, 
        event_type, 
        performed_by, 
        event_date,
        reason
      ) VALUES (
        NEW.id,
        CASE WHEN NEW.is_published THEN 'published' ELSE 'unpublished' END,
        NEW.updated_by,
        NOW(),
        'Status changed via content update'
      );
    END IF;
    
    -- Featured status changed
    IF TG_OP = 'UPDATE' AND OLD.is_featured != NEW.is_featured THEN
      INSERT INTO publication_events (
        article_id, 
        event_type, 
        performed_by, 
        event_date,
        reason
      ) VALUES (
        NEW.id,
        CASE WHEN NEW.is_featured THEN 'featured' ELSE 'unfeatured' END,
        NEW.updated_by,
        NOW(),
        'Featured status changed via content update'
      );
    END IF;
    
  -- Track series publication status changes
  ELSIF TG_TABLE_NAME = 'series' THEN
    -- Publication status changed
    IF TG_OP = 'UPDATE' AND OLD.is_published != NEW.is_published THEN
      INSERT INTO publication_events (
        series_id, 
        event_type, 
        performed_by, 
        event_date,
        reason
      ) VALUES (
        NEW.id,
        CASE WHEN NEW.is_published THEN 'published' ELSE 'unpublished' END,
        NEW.updated_by,
        NOW(),
        'Series status changed via content update'
      );
    END IF;
    
    -- Featured status changed
    IF TG_OP = 'UPDATE' AND OLD.is_featured != NEW.is_featured THEN
      INSERT INTO publication_events (
        series_id, 
        event_type, 
        performed_by, 
        event_date,
        reason
      ) VALUES (
        NEW.id,
        CASE WHEN NEW.is_featured THEN 'featured' ELSE 'unfeatured' END,
        NEW.updated_by,
        NOW(),
        'Series featured status changed via content update'
      );
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER track_article_publication_events_trigger
  AFTER UPDATE ON articles
  FOR EACH ROW EXECUTE FUNCTION track_publication_events();

CREATE TRIGGER track_series_publication_events_trigger
  AFTER UPDATE ON series
  FOR EACH ROW EXECUTE FUNCTION track_publication_events();

-- ============================================================================
-- UPDATED_AT TIMESTAMP MAINTENANCE
-- ============================================================================

-- ----------------------------------------------------------------------------
-- Auto-update updated_at timestamp on record changes
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply to all tables with updated_at column
CREATE TRIGGER update_authors_updated_at 
  BEFORE UPDATE ON authors 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_author_translations_updated_at 
  BEFORE UPDATE ON author_translations 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_categories_updated_at 
  BEFORE UPDATE ON categories 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_category_translations_updated_at 
  BEFORE UPDATE ON category_translations 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_sub_categories_updated_at 
  BEFORE UPDATE ON sub_categories 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_sub_category_translations_updated_at 
  BEFORE UPDATE ON sub_category_translations 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_tags_updated_at 
  BEFORE UPDATE ON tags 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_tag_translations_updated_at 
  BEFORE UPDATE ON tag_translations 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_articles_updated_at 
  BEFORE UPDATE ON articles 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_series_updated_at 
  BEFORE UPDATE ON series 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_article_tags_updated_at 
  BEFORE UPDATE ON article_tags 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_editors_updated_at 
  BEFORE UPDATE ON editors 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_languages_updated_at 
  BEFORE UPDATE ON languages 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_newsletter_subscribers_updated_at 
  BEFORE UPDATE ON newsletter_subscribers 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================================================
-- TRIGGER MAINTENANCE UTILITIES
-- ============================================================================

-- ----------------------------------------------------------------------------
-- Function to disable all sync triggers (for bulk operations)
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION disable_sync_triggers()
RETURNS void AS $$
BEGIN
  -- Disable translation sync triggers
  ALTER TABLE author_translations DISABLE TRIGGER sync_author_translations_trigger;
  ALTER TABLE category_translations DISABLE TRIGGER sync_category_translations_trigger;
  ALTER TABLE sub_category_translations DISABLE TRIGGER sync_sub_category_translations_trigger;
  ALTER TABLE tag_translations DISABLE TRIGGER sync_tag_translations_trigger;
  
  -- Disable series statistics triggers
  ALTER TABLE articles DISABLE TRIGGER update_series_statistics_trigger;
  ALTER TABLE articles DISABLE TRIGGER assign_episode_number_trigger;
  
  -- Disable publication event triggers
  ALTER TABLE articles DISABLE TRIGGER track_article_publication_events_trigger;
  ALTER TABLE series DISABLE TRIGGER track_series_publication_events_trigger;
  
  RAISE NOTICE 'All sync triggers disabled for bulk operations';
END;
$$ LANGUAGE plpgsql;

-- ----------------------------------------------------------------------------
-- Function to enable all sync triggers (after bulk operations)
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION enable_sync_triggers()
RETURNS void AS $$
BEGIN
  -- Enable translation sync triggers
  ALTER TABLE author_translations ENABLE TRIGGER sync_author_translations_trigger;
  ALTER TABLE category_translations ENABLE TRIGGER sync_category_translations_trigger;
  ALTER TABLE sub_category_translations ENABLE TRIGGER sync_sub_category_translations_trigger;
  ALTER TABLE tag_translations ENABLE TRIGGER sync_tag_translations_trigger;
  
  -- Enable series statistics triggers
  ALTER TABLE articles ENABLE TRIGGER update_series_statistics_trigger;
  ALTER TABLE articles ENABLE TRIGGER assign_episode_number_trigger;
  
  -- Enable publication event triggers
  ALTER TABLE articles ENABLE TRIGGER track_article_publication_events_trigger;
  ALTER TABLE series ENABLE TRIGGER track_series_publication_events_trigger;
  
  RAISE NOTICE 'All sync triggers enabled';
END;
$$ LANGUAGE plpgsql;


-- ============================================================================
-- MIGRATION COMPLETE
-- ============================================================================
-- This migration includes:
-- 1. Schema changes (tables, columns, indexes, constraints)
-- 2. Database triggers for automatic data synchronization
-- 3. Multilingual translation table management
-- 4. Series statistics and episode number management
-- 5. Publication event tracking
-- ============================================================================
